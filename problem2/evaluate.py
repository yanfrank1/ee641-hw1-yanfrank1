# -*- coding: utf-8 -*-
"""evaluate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EjQO5W_F17pgnnPFTE_w0z9lQa5ubi_V
"""

import torch
import numpy as np
import matplotlib.pyplot as plt
import os

def extract_keypoints_from_heatmaps(heatmaps):
    """
    Extract (x, y) coordinates from heatmaps.

    Args:
        heatmaps: Tensor of shape [batch, num_keypoints, H, W]

    Returns:
        coords: Tensor of shape [batch, num_keypoints, 2]
    """
    # Find argmax location in each heatmap
    # Convert to (x, y) coordinates
    B, K, H, W = heatmaps.shape
    heatmaps_reshaped = heatmaps.view(B, K, -1)
    indices = torch.argmax(heatmaps_reshaped, dim=2)
    coords = torch.zeros((B, K, 2), device=heatmaps.device, dtype=torch.long)
    coords[:, :, 0] = indices % W
    coords[:, :, 1] = indices // W
    return coords
    pass


def compute_pck(predictions, ground_truths, thresholds, normalize_by='bbox'):
    """
    Compute PCK at various thresholds.

    Args:
        predictions: Tensor [N,K,2] in the same coordinate system as ground_truths
        ground_truths: Tensor [N,K,2]
        thresholds: list of floats
        normalize_by: 'bbox' or 'torso'

    Returns:
        dict threshold -> accuracy
    """
    # For each threshold:
    # Count keypoints within threshold distance of ground truth
    predictions = predictions.float()
    ground_truths = ground_truths.float()
    N, K, _ = predictions.shape
    dists = torch.norm(predictions - ground_truths, dim=2)

    if normalize_by == 'bbox':
        x_min, _ = ground_truths[:, :, 0].min(dim=1)
        x_max, _ = ground_truths[:, :, 0].max(dim=1)
        y_min, _ = ground_truths[:, :, 1].min(dim=1)
        y_max, _ = ground_truths[:, :, 1].max(dim=1)
        diag = torch.sqrt((x_max - x_min) ** 2 + (y_max - y_min) ** 2)
        norm = diag.unsqueeze(1).clamp_min(1e-6)
    else:
        torso_len = torch.norm(ground_truths[:, 0, :] - ground_truths[:, 1, :], dim=1)
        norm = torso_len.unsqueeze(1).clamp_min(1e-6)

    norm_dists = dists / norm
    pck_values = {}
    for t in thresholds:
        correct = (norm_dists <= t).float()
        pck_values[t] = correct.mean().item()
    return pck_values
    pass

def plot_pck_curves(pck_heatmap, pck_regression, save_path):
    """
    Plot PCK curves comparing both methods.
    """
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    thresholds = sorted(pck_heatmap.keys())
    plt.figure()
    plt.plot(thresholds, [pck_heatmap[t] for t in thresholds], label="Heatmap")
    plt.plot(thresholds, [pck_regression[t] for t in thresholds], label="Regression")
    plt.xlabel("Threshold (normalized distance)")
    plt.ylabel("PCK")
    plt.title("PCK Curves")
    plt.legend()
    plt.grid(True)
    plt.savefig(save_path, bbox_inches="tight")
    plt.close()
    pass


def visualize_predictions(image, pred_keypoints, gt_keypoints, save_path):
    """
    Visualize predicted and ground truth keypoints on image.
    """
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    plt.figure()
    if image.ndim == 2:
        plt.imshow(image, cmap="gray")
    else:
        plt.imshow(image)

    plt.scatter(gt_keypoints[:, 0], gt_keypoints[:, 1], c="g", marker="o", label="GT")
    plt.scatter(pred_keypoints[:, 0], pred_keypoints[:, 1], c="r", marker="x", label="Pred")
    plt.legend()
    plt.axis("off")
    plt.savefig(save_path, bbox_inches="tight")
    plt.close()
    pass