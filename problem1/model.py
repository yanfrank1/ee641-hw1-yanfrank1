# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sB4PXqDuKVASA-_njO2sCuN3dFi82WJb
"""

import torch
import torch.nn as nn


class ConvBlock(nn.Module):
    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.block = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, kernel_size=3, stride=2, padding=1),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True),
        )

    def forward(self, x):
        return self.block(x)

class DetectionHead(nn.Module):
    def __init__(self, in_channels, num_anchors, num_classes):
        super().__init__()
        self.conv3x3 = nn.Conv2d(in_channels, in_channels, kernel_size=3, padding=1)
        self.head = nn.Conv2d(in_channels, num_anchors * (5 + num_classes), kernel_size=1)

    def forward(self, x):
        x = self.conv3x3(x)
        return self.head(x)

class MultiScaleDetector(nn.Module):
    def __init__(self, num_classes=3, num_anchors=3):
        """
        Initialize the multi-scale detector.

        Args:
            num_classes: Number of object classes (not including background)
            num_anchors: Number of anchors per spatial location
        """
        super().__init__()
        self.num_classes = num_classes
        self.num_anchors = num_anchors

        # Feature extraction backbone
        # Extract features at 3 different scales

        # Detection heads for each scale
        # Each head outputs: [batch, num_anchors * (4 + 1 + num_classes), H, W]
        self.block1 = ConvBlock(3, 64)
        self.block2 = ConvBlock(64, 128)
        self.block3 = ConvBlock(128, 256)
        self.block4 = ConvBlock(256, 512)

        self.det_head1 = DetectionHead(128, num_anchors, num_classes)
        self.det_head2 = DetectionHead(256, num_anchors, num_classes)
        self.det_head3 = DetectionHead(512, num_anchors, num_classes)

        pass

    def forward(self, x):
        """
        Forward pass.

        Args:
            x: Input tensor of shape [batch, 3, 224, 224]

        Returns:
            List of 3 tensors (one per scale), each containing predictions
            Shape: [batch, num_anchors * (5 + num_classes), H, W]
            where 5 = 4 bbox coords + 1 objectness score
        """
        x = self.block1(x)
        s1 = self.block2(x)
        s2 = self.block3(s1)
        s3 = self.block4(s2)

        out1 = self.det_head1(s1)
        out2 = self.det_head2(s2)
        out3 = self.det_head3(s3)

        return [out1, out2, out3]
        pass